from typing import List, Optional
from pydantic import BaseModel

# TODO: for ints, distinguish between 32 and 64 bit variants

## Abstract classes
# TODO: make abstract
class AbstractThumbnail(BaseModel):
    url: str
    width: int
    height: int

class VideoThumbnail(AbstractThumbnail):
    quality: Optional[str]

class AuthorThumbnail(AbstractThumbnail):
    pass

class AuthorBanner(AbstractThumbnail):
    pass


## /api/v1/videos:id
class Caption(BaseModel):
    label: str
    languageCode: str
    url: str

class AdaptiveFormat(BaseModel):
    index: Optional[str]
    bitrate: Optional[str]
    init: Optional[str]
    url: str
    itag: Optional[str]
    type: Optional[str]   # TODO: will this break?
    clen: Optional[str]
    lmt: Optional[str]
    projectionType: Optional[int]
    container: Optional[str]
    encoding: Optional[str]
    qualityLabel: Optional[str]
    resolution: Optional[str]

class FormatStream(BaseModel):
    url: str
    itag: Optional[str]
    type: Optional[str]
    quality: Optional[str]
    container: Optional[str]
    encoding: Optional[str]
    qualityLabel: Optional[str]
    resolution: Optional[str]
    size: Optional[str]

### Response schemata

class VideosResponse(BaseModel):


    class RecommendedVideo(BaseModel):
        videoId: str
        title: str
        videoThumbnails: List[VideoThumbnail]
        author: str
        lengthSeconds: Optional[int]
        viewCountText: Optional[str]

    title: str
    videoId: str
    videoThumbnails: List[VideoThumbnail]

    description: Optional[str]
    descriptionHtml: Optional[str]
    published: Optional[int]
    publishedText: Optional[str]
    keywords: List[str]
    viewCount: Optional[int]
    likeCount: Optional[int]
    dislikeCount: Optional[int]

    paid: Optional[bool]
    premium: Optional[bool]
    isFamilyFriendly: Optional[bool]
    allowedRegions: Optional[List[str]]
    genre: Optional[str]
    genreUrl: Optional[str]

    author: str
    authorId: str
    authorUrl: str
    authorThumbnails: List[AuthorThumbnail]

    subCountText: Optional[str]
    lengthSeconds: Optional[int]
    allowRatings: Optional[bool]
    rating: Optional[float]
    isListed: Optional[bool]
    liveNow: Optional[bool]
    isUpcoming: Optional[bool]
    premiereTimestamp: Optional[int]

    hlsUrl: Optional[str]
    adaptiveFormats: List[AdaptiveFormat]
    formatStreams: List[FormatStream]
    captions: List[Caption]
    recommendedVideos: List[RecommendedVideo]


#/api/v1/channels/:ucid
class LatestVideo(BaseModel):
    title: str
    videoId: str
    author: str
    authorId: str
    authorUrl: str

    videoThumbnails: List[VideoThumbnail]

    description: Optional[str]
    descriptionHtml: Optional[str]
    viewCount: Optional[int]
    published: Optional[int]
    publishedText: Optional[str]
    lengthSeconds: Optional[int]
    paid: Optional[bool]
    premium: Optional[bool]

class RelatedChannel(BaseModel):
    author: str
    authorId: str
    authorUrl: str
    authorThumbnails: List[AuthorThumbnail]

class ChannelsResponse(BaseModel):
    author: str
    authorId: str
    authorUrl: str
    authorBanners: List[AuthorBanner]
    authorThumbnails: List[AuthorThumbnail]

    subcount: Optional[int]
    totalViews: Optional[int]
    joined: Optional[int]

    paid: Optional[bool]
    autoGenerated: Optional[bool]
    isFamilyFriendly: Optional[bool]
    description: Optional[str]
    descriptionHtml: Optional[str]
    allowedRegions: Optional[List[str]]

    latestVideos: List[LatestVideo]
    relatedChannels: Optional[List[RelatedChannel]]
