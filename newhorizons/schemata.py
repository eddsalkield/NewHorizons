from typing import List, Optional
from pydantic import BaseModel, Extra

# TODO: for ints, distinguish between 32 and 64 bit variants

# Sub-models should have extra=Extra.forbid, since they are used for typechecking
#   and subsequent reporting
# Top-level models should have extra=Extra.ignore, to ensure that we strictly
#   adhere to the API when returning

## Abstract classes
# TODO: make abstract

# TODO: validator to log whenever non-square thumbnails are found
class AbstractThumbnail(BaseModel, extra=Extra.forbid):
    url: str
    width: int
    height: int

class VideoThumbnail(AbstractThumbnail, extra=Extra.forbid):
    quality: Optional[str]

class AuthorThumbnail(AbstractThumbnail, extra=Extra.forbid):
    pass

class AuthorBanner(AbstractThumbnail, extra=Extra.forbid):
    pass


class Caption(BaseModel, extra=Extra.forbid):
    label: str
    languageCode: str
    url: str

class AdaptiveFormat(BaseModel, extra=Extra.forbid):
    index: Optional[str]
    bitrate: Optional[str]
    init: Optional[str]
    url: str
    itag: Optional[str]
    type: Optional[str]   # TODO: will this break?
    clen: Optional[str]
    lmt: Optional[str]
    projectionType: Optional[int]
    container: Optional[str]
    encoding: Optional[str]
    qualityLabel: Optional[str]
    resolution: Optional[str]

class FormatStream(BaseModel, extra=Extra.forbid):
    url: str
    itag: Optional[str]
    type: Optional[str]
    quality: Optional[str]
    container: Optional[str]
    encoding: Optional[str]
    qualityLabel: Optional[str]
    resolution: Optional[str]
    size: Optional[str]

### Response schemata

## /api/v1/videos:id
class VideosResponse(BaseModel, extra=Extra.ignore):
    class RecommendedVideo(BaseModel, extra=Extra.forbid):
        videoId: str
        title: str
        videoThumbnails: List[VideoThumbnail]
        author: str
        lengthSeconds: Optional[int]
        viewCountText: Optional[str]

    title: str
    videoId: str
    videoThumbnails: List[VideoThumbnail]

    description: Optional[str]
    descriptionHtml: Optional[str]
    published: Optional[int]
    publishedText: Optional[str]
    keywords: List[str]
    viewCount: Optional[int]
    likeCount: Optional[int]
    dislikeCount: Optional[int]

    paid: Optional[bool]
    premium: Optional[bool]
    isFamilyFriendly: Optional[bool]
    allowedRegions: Optional[List[str]]
    genre: Optional[str]
    genreUrl: Optional[str]

    author: str
    authorId: str
    authorUrl: str
    authorThumbnails: List[AuthorThumbnail]

    subCountText: Optional[str]
    lengthSeconds: Optional[int]
    allowRatings: Optional[bool]
    rating: Optional[float]
    isListed: Optional[bool]
    liveNow: Optional[bool]
    isUpcoming: Optional[bool]
    premiereTimestamp: Optional[int]

    hlsUrl: Optional[str]
    adaptiveFormats: List[AdaptiveFormat]
    formatStreams: List[FormatStream]
    captions: List[Caption]
    recommendedVideos: List[RecommendedVideo]


class LatestVideo(BaseModel, extra=Extra.forbid):
    title: str
    videoId: str
    author: str
    authorId: str
    authorUrl: str

    videoThumbnails: List[VideoThumbnail]

    description: Optional[str]
    descriptionHtml: Optional[str]
    viewCount: Optional[int]
    published: Optional[int]
    publishedText: Optional[str]
    lengthSeconds: Optional[int]
    paid: Optional[bool]
    premium: Optional[bool]

class RelatedChannel(BaseModel, extra=Extra.forbid):
    author: str
    authorId: str
    authorUrl: str
    authorThumbnails: List[AuthorThumbnail]

#/api/v1/channels/:ucid
class ChannelsResponse(BaseModel, extra=Extra.ignore):
    author: str
    authorId: str
    authorUrl: str
    authorBanners: List[AuthorBanner]
    authorThumbnails: List[AuthorThumbnail]

    subCount: Optional[int]
    totalViews: Optional[int]
    joined: Optional[int]

    paid: Optional[bool]
    autoGenerated: Optional[bool]
    isFamilyFriendly: Optional[bool]
    description: Optional[str]
    descriptionHtml: Optional[str]
    allowedRegions: Optional[List[str]]

    latestVideos: Optional[List[LatestVideo]]
    relatedChannels: Optional[List[RelatedChannel]]
